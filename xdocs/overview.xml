<?xml version="1.0"?>

<document>

 <properties>
  <title>Betwixt Overview</title>
  <author email="jstrachan@apache.org">James Strachan</author>
 </properties>

<body>

<section name="Getting Started">
    <p>
    Probably the best way to get started is to look at some examples. 
    <a href='#simple-example'>Here</a> is some simple example code that reads and writes a bean (together
    with some comments). It's a good place to start. 
    </p>
</section>

<section name="Mapping beans to XML">

    <p>There are various ways of mapping beans to an XML structure. For example 
    consider a simple bean</p>
    
<source><![CDATA[public class CustomerBean {
    public String getName();
    public Order[] getOrders();
    public String[] getEmailAddresses();
}]]></source>
    
    <p>This could be mapped to XML in various ways. 
    A couple of examples of these different ways follow.</p>


<subsection name="Example 1">
    
    <p>This example uses attributes for primitive types.</p>

<source><![CDATA[<CustomerBean name='James'>
    <order id='1'>...</order>
    <order id='2'>...</order>
    <emailAddress>jstrachan@apache.org</emailAddress>
</CustomerBean>]]></source>
</subsection>
    
    
    <subsection name="Example 2">
    
    <p>This example uses elements for all properties and wraps collections in an 
    extra element (which can be quite common in XML schemas). Also note that some 
    element names have been changed.</p>
    
<source><![CDATA[<customer>
    <name>James</name>
    <orders>
        <order id='1'>...</order>
        <order id='2'>...</order>
    </orders>
    <email-addresses>
        <email-address>jstrachan@apache.org</email-address>
    </email-addresses>
</customer>    ]]></source>
    
    <p>Betwixt aims to provide a diversity of possible mappings such that the 
    developer can choose, if they wish, how their beans appear as XML to support 
    whatever XML encoding scheme that is desired. If no particular mapping is 
    provided then Betwixt will create a default mapping for you. Also the 
    customization mechanism allows you to just override the parts you want to and 
    let Betwixt default the rest. So if you just want to rename a property in XML 
    for a certain type, thats all you need to do. No need to hand-code what Betwixt 
    can deduce for itself. </p>
</subsection>

</section>

<section name="Customizing the mapping of a bean to XML (basic)">
    
<subsection name=".betwixt files">

    <p>The XMLIntrospector will look for files of the form <i>className.betwixt</i> 
    on the classpath using the same ClassLoader used to load the given class and use 
    that document to specify the mapping to XML. If this file does not exist 
    then the default introspection rules are used.</p>
    <p>The simplest possible file may just set the name of the element. e.g.</p>
    
<source><![CDATA[<?xml version='1.0' encoding='UTF-8' ?>
<info>
<element name='channel'/>
<addDefaults/>
</info>]]></source>
    
    <p>The above means to use the name 'channel' for the outer most element for the 
    given type. The <code>&lt;addDefaults&gt;</code> means to add the defaults from the introspector. 
    This allows you to just rename a few properties then let the introspector do the 
    rest. There is also a <code>&lt;hide&gt;</code> element which allows one or more properties to be 
    hidden. Also note that the <code>&lt;element&gt;</code> and 
    <code>&lt;attribute&gt;</code> tags can be nested to any 
    kind of depth allowing whatever XML structure you wish. This can be useful if 
    you wish to wrap collections in some arbitrary collection tags or to group 
    properties of a bean together in some XML structure. e.g.</p>
    
<source><![CDATA[<?xml version='1.0' encoding='UTF-8' ?>
<info primitiveTypes='attribute'>
<hide property='something'/>
<element name='channel'/>
    <element name='customerList'>
    <element name='customer' property='customers'/>
    </element>
    <element name='foo'>
    <attribute name='qqq' property='ppp'/>
    <element name='bar' property='xyz'/>
    <addDefaults/>
</element>
</info>
]]></source>
    
    <p>Note that the <code>.betwixt</code> file specifies the mapping for a single bean.
    So, whilst you can add extra elements (as above), it can't be used to specify 
    to names for child beans through nesting <code>element</code> elements.</p>
    
    <p>The primitiveTypes attribute in the <code>&lt;info&gt;</code> element is 
    optional and can be used to specify whether primitive java types (strings, numbers, dates etc) are 
    specified as attributes or elements by default.</p>
    <p>Finally static text can be specified using a value attribute inside an 
    <code>&lt;element&gt;</code> or <code>&lt;attribute&gt;</code> tag. 
    e.g. to add constant attributes such as a version label to the 
    generated XML...</p>
    
<source><![CDATA[<?xml version='1.0' encoding='UTF-8' ?>
<info primitiveTypes='element'>
<element name='rss'/>
    <attribute name='version' value='0.91'/>
    <element name='channel'/>
    <addDefaults/>
</element>
</info>
]]></source>

</subsection>

</section>

<section name="Bean naming conventions">

    <p>The Java Beans specification contains various naming conventions that should 
    be used when writing beans that will allow the beans introspector to 
    automatically guess the properties in a bean and their getters, their
    setter methods etc. Betwixt will use these same naming conventions to deduce how to make the 
    beans appear as XML. There are some other naming conventions that you can use to 
    make your beans easier to output as XML or parse.
    </p>
    
    <p>
    One common requirement when mapping beans to xml is that the property and type names from the bean 
    must be processed (in some way) before they are used in the xml. For example, a property 
    called <code>WebApp</code> might need to be mapped to an element called <code>web-app</code>.
    </p>
    
    <p>
    Betwixt supports customization of these mappings through plug-in implementations of the 
    <code>org.apache.commons.betwixt.strategy.NameMapper</code> interface. It is often useful to allow
    different mappings for elements and attribute and so different implementations can be set for 
    elements and attributes. The default NameMapper implementation simply returns the type name 
    without modification.
    </p>
    
    <p>
    <strong>Note</strong> that the attribute and element names given in a .betwixt file (as usual)
    override the name mapping settings on the <code>XMLIntrotrospector</code>.
    </p>

<subsection name="Using a custom type name to element name mapping">

    <p>
    Betwixt supports pluggable conversion of type names to element names. Setting the 
    <code>ElementNameMapper</code> property on an <code>XMLIntrospector</code> determines
    how names from the bean will be converted into element names.
    </p>

</subsection>


<subsection name="Using a custom property name to attribute name mapping">

    <p>
    Betwixt supports pluggable conversion of type names to attribute names. Setting the 
    <code>AttributeNameMapper</code> property on an <code>XMLIntrospector</code> determines
    how names from the bean will be converted into attribute names.
    </p>

</subsection>

<subsection name="Custom Mapping Example">

    <p>
    Here's a simple bean which will be mapped to xml:
    
<source><![CDATA[
public class TallTreeBean {

    private float heightOfTree;
    
    public TallTreeBean(float height) {
        setHeightOfTree(height);
    }
    
    public float getHeightOfTree() {
        return heightOfTree;
    }	
    
    public void setHeightOfTree(float heightOfTree) {
        this.heightOfTree = heightOfTree;
    }
}	
]]></source>

    </p>
    <p>
    Next is an application that writes that bean to xml. Custom name mappers for elements
    and attributes are set.
    
<source><![CDATA[
import org.apache.commons.betwixt.io.BeanWriter;
import org.apache.commons.betwixt.strategy.DecapitalizeNameMapper;
import org.apache.commons.betwixt.strategy.HyphenatedNameMapper;

public class NameMapperExampleApp {
    
    public static final void main(String args[]) throws Exception{
        
        // create write and set basic properties
	BeanWriter writer = new BeanWriter();
        writer.getXMLIntrospector().setAttributesForPrimitives(true);
        writer.enablePrettyPrint();
        writer.setWriteIDs(false);
        
        // set a custom name mapper for attributes
        writer.getXMLIntrospector().setAttributeNameMapper(new HyphenatedNameMapper());
        // set a custom name mapper for elements
        writer.getXMLIntrospector().setElementNameMapper(new DecapitalizeNameMapper());
        
        // write out the bean
        writer.write(new TallTreeBean(15.1f));
        System.out.println("");
    }
    
}
]]></source>
    </p>
    
    <p>
    The application should print out (to System.out) an xml fragment which looks like:
    
<source><![CDATA[
<tallTreeBean height-of-tree="15.1"/>
]]></source>
    
    </p>
    <p>
    As you can see, the first letter of the element name has been decapitalized and the 
    capitals in the property separated by hyphens after being converted to lower case.
    </p>
</subsection>

</section>

<section name="Using adder methods for composite properties">

    <p>
    This naming convention is used to indicate the singular type of some composite property.
    </p>
    
    <p>
    To use: create an add method to match the getter method for 'composite 
    properties'.
    </p>

<source><![CDATA[public class SomeBean {
    public <CollectionType> getFoo*();
    public void addFoo(<SingularType> foo);
}]]></source>

    <p>
    Where CollectionType can be an array, a Collection, Enumeration, Iterator, 
    Map. The [SinglularType] refers to the type of an item in the collection. The 
    name of the getter property starts with 'Foo'. So 'Foo' is the singular name, 
    the plural collection name could be Foos, FooArray, FooList, FooIterator or some 
    other encoding, though the plural name should start with the singular name for 
    auto-detection to work properly.
    </p>

<subsection name="Using a custom plural stemmer">
    <p>
    Betwixt allows this auto-detection of plurals from singulars to be customized.
    Implementations of <code>org.apache.commons.betwixt.PluralStemmer</code> allow different
    strategies for this mapping to be plugged into <code>XMLIntrospector</code>.
    The strategy used by <code>XMLIntrospector</code> to match singlular properties and plural methods
    is determined by the <code>PluralStemmer</code> property value.
    </p>

    <p>
    One important usage of custom plural stemmers is to support classes with non-english method names.
    A custom <code>PluralStemmer</code> implementation can be created containing the plural rules for
    the language. Betwixt will then be able to recognize matching plural and singular methods.
    </p>

    <p>
    The default implementation supports common english plural patterns and then falls back to finding
    any property that starts with the singular name. For example, it will match a plural property called
    <code>FooBars</code> for a singular property called <code>FooBar</code>. 
    </p>
</subsection>

</section>

<section name="Customizing the mapping of a bean to XML (advanced)">

<subsection name="Caching and XMLRegistry">
    
    <p>
    Introspection is slow and so caching the results improves preformance. Though the writers 
    and readers can - by nature - only be used safely in a single thread, a single 
    <code>XMLIntrospector</code> instance can be safely shared amongst multiple threads. Sharing a
    single instance will improve performance by sharing it's <code>XMLBeanInfo</code> cache.
    </p>
    
    <p>
    The <code>XMLBeanInfoRegistry</code> interface allows finely grained, pluggable control over 
    the caching strategy used by a <code>XMLIntrospector</code>. The implementation used can be set
    by passing an instance to <code>XMLIntrospector.setRegistry</code>.
    </p>
    
    <p>
    Before using the standard introspection techniques to create a new <code>XMLBeanInfo</code> instance
    for a bean, the current <code>XMLBeanInfoRegistry</code> is first checked. Only if the registry 
    does not return an <code>XMLBeanInfo</code> will a new one be created. Once a new instance has been
    created by introspection, the <code>XMLBeanInfoRegistry</code> implementation will be called so that
    the <code>XMLBeanInfo</code> can (if required) be cached.
    </p>
    
    <p>
    The default strategy caches everything and supports flushes. Betwixt contains an alternative 
    implementation that does not cache anything. Users that require more sophisticated caching 
    strategies should create custom implementations.
    </p>
    
    <p>
    The <code>XMLBeanInfoRegistry</code> can also be used to override the standard introspection mechanism
    on a per class basis. The safest way to do this is to create a custom <code>XMLBeanInfoRegistry</code> 
    implementation that pre-loads <code>XMLBeanInfo</code>'s for the required classes. If flush is called, 
    the cache should be reset that it contains only those that it contained at the start. 
    </p>

</subsection>

<subsection name="Other XMLIntrospector Settings">
    
    <p>
    Here are discussed the important settings that haven't been covered already. 
    </p>
    
    <p>
    The <strong><code>AttributesForPrimitives</code></strong> property determines whether a primitive
    type (including strings) should be - by default - mapped to elements or attributes. For example, a
    property called <code>Age</code> of a bean called <code>PersonBean</code> would be mapped to something
    like:
    
<source><![CDATA[
        <PersonBean>
            <age>21</age>
            ...
]]></source>
    
    when <code>isAttributesForPrimitives</code> is false but to 
    
<source><![CDATA[
        <PersonBean age='21'>
            ...
]]></source>
    
    when it is true.
    </p>
    
    <p>
    The <strong><code>WrapCollectionsInElement</code></strong> property determines whether the elements 
    for a composite property (ie one that returns a collection or iterator) should be wrapped in a parent
    element. For example, if <code>isWrapCollectionsInElement</code> is true then a property with signature 
    <code>List getChildren()</code> would wrap a <code>&lt;children&gt;</code> element around the elements
    representing the contents of the list.
    </p>
</subsection>

<subsection name="Using .betwixt files To Write Mixed Content">
    <p>
    An element with mixed content contains child elements and text. 
    For example, element <code>foo</code> has mixed content in the following:
<source>
<![CDATA[<foo>
        Some text
        <bar/>
    </foo>]]>
</source>
    Betwixt supports writing mixed content through <code>text</code> elements in the 
    .betwixt file. 
    </p>
    
    <p>
    A <code>text</code> element can be mapped to a property in which case it must have
    a <code>property</code> attribute and may (optionally) have a <code>type</code> attribute.
    Otherwise, the <code>text</code> element is mapped to a static value, in which case it
    must have a <code>value</code> attribute. If a <code>text</code> element has both 
    <code>value</code> and <code>property</code> attributes then an exception will be thrown.
    </p>
    
    <p>
    For example, a simple bean with the .betwixt file 
<source><![CDATA[<?xml version="1.0" encoding="UTF-8" ?>
<info primitiveTypes="attribute">
    <element name='foo'>
        <attribute name='version' value='1.0'/>
        <element name='bar'>
            <attribute name='version' property='alpha'/>
            <text value='static text'/>
            <element name='baa' property='beta'/>
            <text property='gamma'/>
        </element>
    </element>
</info>]]>
</source>
    and with property values alpha='One', beta='Two' and gamma='Three' will write an output like:
<source>
<![CDATA[<foo version="1.0">
    <bar version="One">static text<baa>Two</baa>Three</bar>
</foo>
]]></source>
    </p>
    
    <p><strong>Note</strong>Betwixt does not (at the moment) support reading mixed 
    content elements.</p>

</subsection>

</section>

<section name='Reading Beans (Advanced)'>
<subsection name='Adding Custom Digestion Rules'>
    <p>
    Betwixt builds on <code>Apache Digester</code> for bean reading. 
    <code>BeanReader</code> extends <code>Digester</code> 
    and this makes a wide range of functionality available.
    </p>
    
    <p>
    Digester uses <code>Rule</code>'s to specify the xml mapping (for more details see the 
    <a href='http://jakarta.apache.org/commons/digester.html'>Digester documentation</a>).
    Betwixt provides a custom ruleset (<code>BeanRuleSet</code>). This creates <code>Rule</code>'s that
    implement the standard Betwixt mapping for a class. <code>BeanReader.registerBeanClass</code> 
    uses this <code>RuleSet</code> to add these standard betwixt mapping <code>Rule</code>'s
    for the bean class.
    </p>
    
    <p>
    These standard Betwixt mapping rules can be integrated with other Digester <code>Rule</code>'s.
    <code>Rule</code>'s added before <code>registerBeanClass</code> is called will come before (in a 
    Digester sense) the standard betwixt <code>Rule</code>'s. Those added after will come afterwards.
    </p>
    
    <p>
    <strong>Note</strong> that care must be taken with the patterns for additional <code>Rule</code>'s.
    The standard Betwixt mapping will only work if all it's <code>Rule</code>'s are matched.
    </p>
    
</subsection>
<subsection name='Advanced Updaters'>
    <p>
Betwixt by default uses the property write method for standard properties 
and matched stems for composite properties (for more details, see 
<a href="#Using adder methods for composite properties">here</a>) 
to update property values when reading beans. 
These approaches should be sufficient for most cases. 
But this can be overruled on a per element basis.
    </p>
    <p>
By using a .betwixt file, the method used to update the bean can be controlled on a per element basis.
When the value of the <code>updater</code> attribute of an <code>&lt;element&gt;</code> element is set,
Betwixt will try to find a bean method with a matching name which takes a single parameter.
When such a matching method exists, this will be called to update the property value.
    </p>
    <p>
For example, the following betwixt file fragment: 
    
<source><![CDATA[
<?xml version="1.0" encoding="UTF-8" ?>
<info primitiveTypes="element">
  <element name="bean">
        ...
        <element name='name' property='name' updater='nameSetter'/>
        ...
  </element>
</info>
]]></source>

will look for a method called 'nameSetter' and use that to update the value mapped to the 'name' element.
    </p>
</subsection>
</section>

<section name="Examples">
<a name="simple-example"/>
<subsection name='A Simple Example'>
    <p>
    This is a simple example to help those new to betwixt. It shows how a simple bean can be converted to
    xml and back again. A round trip, no less!
    </p>
    <p>
    In order to run these simple examples, the classpath needs to contain Betwixt and all it's 
    <a href='dependencies'>dependencies</a>. Note that any 
    <a href='http://java.sun.com/xml/jaxp/index.html'>JAXP (1.1 or later)</a> compliant parser 
    can be used to replace xerces and xml-apis. JUnit is not required to run betwixt (but is needed
    if you want to run the unit tests in CVS).
    </p>
    <p>
    This example is based around a very simple bean representing a person:
    
<source><![CDATA[
public class PersonBean {
    
    private String name;
    private int age;
    
    /** Need to allow bean to be created via reflection */
    public PersonBean() {}
    
    public PersonBean(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }	
    
    public int getAge() {
        return age;
    }
    
    public void setAge(int age) {
        this.age = age;
    }
    
    public String toString() {
        return "PersonBean[name='" + name + "',age='" + age + "']";
    }
}
]]></source>
    </p>
    <p>
    The basic usage pattern for writing beans using Betwixt is to create a BeanWriter, configure it 
    and then pass a bean into the <code>write</code> method. Pretty easy. 
    </p>
    <p>
    Here's a simple application which converts a person bean to xml which is then sent to <code>System.out</code>:
    
<source><![CDATA[
import java.io.StringWriter;

import org.apache.commons.betwixt.io.BeanWriter;

public class WriteExampleApp {

    /** 
     * Create an example bean and then convert it to xml.
     */
    public static final void main(String [] args) throws Exception {
        
        // Start by preparing the writer
        // We'll write to a string 
        StringWriter outputWriter = new StringWriter(); 
        
        // Betwixt just writes out the bean as a fragment
        // So if we want well-formed xml, we need to add the prolog
        outputWriter.write("<?xml version='1.0' ?>");
        
        // Create a BeanWriter which writes to our prepared stream
        BeanWriter beanWriter = new BeanWriter(outputWriter);
        
        // Configure betwixt
        // For more details see java docs or later in the main documentation
        beanWriter.getXMLIntrospector().setAttributesForPrimitives(false);
        beanWriter.setWriteIDs(false);
        beanWriter.enablePrettyPrint();
        
        // Write example bean as base element 'person'
        beanWriter.write("person", new PersonBean("John Smith", 21));
        
        // Write to System.out
        // (We could have used the empty constructor for BeanWriter 
        // but this way is more instructive)
        System.out.println(outputWriter.toString());
    }
}

]]></source>
    </p>
    <p>
    Ths basic usage pattern for reading beans is only a little more complex. This time, you need to
    create a BeanReader, configure it, register the bean classes that the xml will be mapped to and 
    then parse should be called.
    </p>
    <p>
    Here's a simple application that converts some xml to a person bean. The bean is then converted
    to string and the result sent to <code>System.out</code>:
    
<source><![CDATA[
import java.io.StringReader;

import org.apache.commons.betwixt.io.BeanReader;

public class ReadExampleApp {
    
    public static final void main(String args[]) throws Exception{
        
        // First construct the xml which will be read in
        // For this example, read in from a hard coded string
        StringReader xmlReader = new StringReader(
                    "<?xml version='1.0' ?><person><age>25</age><name>James Smith</name></person>");
        
        // Now convert this to a bean using betwixt
        // Create BeanReader
        BeanReader beanReader  = new BeanReader();
        
        // Configure the reader
        // If you're round-tripping, make sure that the configurations are compatible!
        beanReader.getXMLIntrospector().setAttributesForPrimitives(false);
        beanReader.setMatchIDs(false);
        
        // Register beans so that betwixt knows what the xml is to be converted to
        // Since the element mapped to a PersonBean isn't called the same, 
        // need to register the path as well
        beanReader.registerBeanClass("person", PersonBean.class);
        
        // Now we parse the xml
        PersonBean person = (PersonBean) beanReader.parse(xmlReader);
        
        // send bean to system out
        System.out.println(person);
    }
    
}
]]></source>
    </p>
</subsection>
<subsection name='A Rich Site Summary Mapping'>

    <p>In the RSS example from Digester there's a bean which matches this pattern.</p>

<source><![CDATA[
public class Channel

    public Item[] getItems();

    public void addItem(Item item);
}
]]></source>

    <p>This means that the following bean does not match this naming convention, 
    since the plural property name does not start with the singular name.</p>
    
<source><![CDATA[public class Foo {
    public Collection getPeople();
    public void addPerson(Person person);
}]]></source>

    <p>Though these two beans do match</p>

<source><![CDATA[public class Foo {
    public Collection getPersonCollection();
    public void addPerson(Person person);
}
public class Foo {
    public Iterator getPersonIterator();
    public void addPerson(Person person);
}
]]></source>

    <p>The following are other valid examples of <i>composite-getter</i> methods and 
    their matching <i>adder</i> methods.</p>

<table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%">
  <tr>
    <td width="50%" align="center"><b>Composite getter method</b></td>
    <td width="50%" align="center"><b>Adder method</b></td>
  </tr>
  <tr>
    <td width="50%" align="center">getChildren()</td>
    <td width="50%" align="center">addChild()</td>
  </tr>
  <tr>
    <td width="50%" align="center">getPersonList()</td>
    <td width="50%" align="center">addPerson()</td>
  </tr>
  <tr>
    <td width="50%" align="center">getItems()</td>
    <td width="50%" align="center">addItem()</td>
  </tr>
  <tr>
    <td width="50%" align="center">getChannels()</td>
    <td width="50%" align="center">addChannel()</td>
  </tr>
  <tr>
    <td width="50%" align="center">getSheep()</td>
    <td width="50%" align="center">addSheep()</td>
  </tr>
</table>

</subsection>

</section>


</body>
</document>
